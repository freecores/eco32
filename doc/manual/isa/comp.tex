\section{Computation Instructions}

\newcommand{\rdivzero}{\effect if $R_y=0$ then trigger a \name{Division by Zero Fault}}
\newcommand{\idivzero}{\effect if $y=0$ then trigger a \name{Division by Zero Fault}}

The computation instructions compute a function of register values and/or immediate values, and store their result in a general-purpose register.

\subsection{ADD}

The ADD instruction computes the sum of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{000000}

\regeffects{truncate_{32}(R_x + R_y)}

\subsection{ADDI}

The ADDI instruction computes the sum of a 32-bit register operand and a sign-extended 16-bit immediate operand, truncated to 32 bits.\\

\rriformat{000001}

\regeffects{truncate_{32}(R_x + signext_{32}(y))}

\subsection{SUB}

The SUB instruction computes the difference of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{000010}

\regeffects{truncate_{32}(R_x - R_y)}

\subsection{SUBI}

The SUBI instruction computes the difference of a 32-bit register operand and a sign-extended 16-bit immediate operand, truncated to 32 bits.\\

\rriformat{000011}

\regeffects{truncate_{32}(R_x - signext_{32}(y))}

\subsection{MUL}

The MUL instruction computes the signed product of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{000100}

\regeffects{truncate_{32}(R_x *_{signed} R_y)}

\subsection{MULI}

The MULI instruction computes the signed product of a 32-bit register operand and a sign-extended 16-bit immediate operand, truncated to 32 bits.\\

\rriformat{000101}

\regeffects{truncate_{32}(R_x *_{signed} signext_{32}(y))}

\subsection{MULU}

The MULU instruction computes the unsigned product of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{000110}

\regeffects{truncate_{32}(R_x *_{unsigned} R_y)}

\subsection{MULUI}

The MULUI instruction computes the unsigned product of a 32-bit register operand and a zero-extended 16-bit immediate operand, truncated to 32 bits.\\

\rriformat{000111}

\regeffects{truncate_{32}(R_x *_{unsigned} zeroext_{32}(y))}

\subsection{DIV}

The DIV instruction computes the signed quotient of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{001000}

\begin{effectize}
\rdivzero
\regeffect{truncate_{32}(R_x /_{signed} R_y)}
\end{effectize}

\subsection{DIVI}

The DIVI instruction computes the signed quotient of a 32-bit register operand and a sign-extended 16-bit immediate operand, truncated to 32 bits.\\

\rrrformat{001001}

\begin{effectize}
\idivzero
\regeffect{truncate_{32}(R_x /_{signed} signext_{32}(y))}
\end{effectize}

\subsection{DIVU}

The DIVU instruction computes the unsigned quotient of two unsigned 32-bit register operands, truncated to 32 bits.\\

\rrrformat{001010}

\begin{effectize}
\rdivzero
\regeffect{truncate_{32}(R_x /_{unsigned} R_y)}
\end{effectize}

\subsection{DIVUI}

The DIVUI instruction computes the unsigned quotient of a 32-bit register operand and a zero-extended 16-bit immediate operand, truncated to 32 bits.\\

\rrrformat{001011}

\begin{effectize}
\idivzero
\regeffect{truncate_{32}(R_x /_{unsigned} zeroext_{32}(y))}
\end{effectize}

\subsection{REM}

The REM instruction computes the signed remainder of two 32-bit register operands, truncated to 32 bits.\\

\rrrformat{001100}

\begin{effectize}
\rdivzero
\regeffect{truncate_{32}(R_x MOD_{signed} R_y)}
\end{effectize}

\subsection{REMI}

The REMI instruction computes the signed remainder of a 32-bit register operand and a sign-extended 16-bit immediate operand, truncated to 32 bits.\\

\rrrformat{001101}

\begin{effectize}
\idivzero
\regeffect{truncate_{32}(R_x MOD_{signed} signext_{32}(y))}
\end{effectize}

\subsection{REMU}

The REMU instruction computes the unsigned remainder of two unsigned 32-bit register operands, truncated to 32 bits.\\

\rrrformat{001110}

\begin{effectize}
\rdivzero
\regeffect{truncate_{32}(R_x MOD_{unsigned} R_y)}
\end{effectize}

\subsection{REMUI}

The REMUI instruction computes the unsigned remainder of a 32-bit register operand and a zero-extended 16-bit immediate operand, truncated to 32 bits.\\

\rrrformat{001111}

\begin{effectize}
\idivzero
\regeffect{truncate_{32}(R_x MOD_{unsigned} zeroext_{32}(y))}
\end{effectize}

\subsection{AND}

The AND instruction computes the bitwise AND of two 32-bit register operands.\\

\rrrformat{010000}

\bitregeffects{R_{x,i} \wedge R_{y,i}}

\subsection{ANDI}

The ANDI instruction computes the bitwise AND of a 32-bit register operand and a zero-extended 16-bit immediate operand.\\

\rriformat{010001}

\bitregeffects{R_{x,i} \wedge zeroext_{32}(y)_i}

\subsection{OR}

The OR instruction computes the bitwise OR of two 32-bit register operands.\\

\rrrformat{010010}

\bitregeffects{R_{x,i} \vee R_{y,i}}

\subsection{ORI}

The ORI instruction computes the bitwise OR of a 32-bit register operand and a zero-extended 16-bit immediate operand.\\

\rriformat{010011}

\bitregeffects{R_{x,i} \vee zeroext_{32}(y)_i}

\subsection{XOR}

The XOR instruction computes the bitwise XOR of two 32-bit register operands.\\

\rrrformat{010100}

\bitregeffects{R_{x,i} \oplus R_{y,i}}

\subsection{XORI}

The XORI instruction computes the bitwise XOR of a 32-bit register operand and a zero-extended 16-bit immediate operand.\\

\rriformat{010101}

\bitregeffects{R_{x,i} \oplus zeroext_{32}(y)_i}

\subsection{XNOR}

The XNOR instruction computes the bitwise XNOR of two 32-bit register operands.\\

\rrrformat{010110}

\bitregeffects{\overline{R_{x,i} \oplus R_{y,i}}}

\subsection{XNORI}

The XNORI instruction computes the bitwise XNOR of a 32-bit register operand and a zero-extended 16-bit immediate operand.\\

\rriformat{010111}

\bitregeffects{\overline{R_{x,i} \oplus zeroext_{32}(y)_i}}

\subsection{SLL}

The SLL instruction computes the result of shifting the first 32-bit register operand to the left by a number of bits specified by the 5 least significant bits of the second 32-bit register operand, and filling up with 0 bits.\\

\rrrformat{011000}

\begin{effectize}
\effect $shift \leftarrow unsigned(R_{y,4..0})$
\effect $temp_i \leftarrow R_{x,i-shift}$ if $i \geq shift$
\effect $temp_i \leftarrow 0$ if $i < shift$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{SLLI}

The SLLI instruction computes the result of shifting the 32-bit register operand to the left by a number of bits specified by the 5 least significant bits of the immediate operand, and filling up with 0 bits.\\

\rriformat{011001}

\begin{effectize}
\effect $shift \leftarrow unsigned(y_{4..0})$
\effect $temp_i \leftarrow R_{x,i-shift}$ if $i \geq shift$
\effect $temp_i \leftarrow 0$ if $i < shift$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{SLR}

The SLR instruction computes the result of shifting the first 32-bit register operand to the right by a number of bits specified by the 5 least significant bits of the second 32-bit register operand, and filling up with 0 bits.\\

\rrrformat{011010}

\begin{effectize}
\effect $shift \leftarrow unsigned(R_{y,4..0})$
\effect $temp_i \leftarrow R_{x,i+shift}$ if $i + shift < 32$
\effect $temp_i \leftarrow 0$ if $i + shift \geq 32$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{SLRI}

The SLRI instruction computes the result of shifting the 32-bit register operand to the right by a number of bits specified by the 5 least significant bits of the immediate operand, and filling up with 0 bits.\\

\rriformat{011011}

\begin{effectize}
\effect $shift \leftarrow unsigned(y_{4..0})$
\effect $temp_i \leftarrow R_{x,i+shift}$ if $i + shift < 32$
\effect $temp_i \leftarrow 0$ if $i + shift \geq 32$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{SAR}

The SAR instruction computes the result of shifting the first 32-bit register operand to the right by a number of bits specified by the 5 least significant bits of the second 32-bit register operand, and replicating the topmost (sign) bit.\\

\rrrformat{011100}

\begin{effectize}
\effect $shift \leftarrow unsigned(R_{y,4..0})$
\effect $temp_i \leftarrow R_{x,i+shift}$ if $i + shift < 32$
\effect $temp_i \leftarrow R_{x,31}$ if $i + shift \geq 32$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{SARI}

The SARI instruction computes the result of shifting the 32-bit register operand to the right by a number of bits specified by the 5 least significant bits of the immediate operand, and replicating the topmost (sign) bit.\\

\rriformat{011101}

\begin{effectize}
\effect $shift \leftarrow unsigned(y_{4..0})$
\effect $temp_i \leftarrow R_{x,i+shift}$ if $i + shift < 32$
\effect $temp_i \leftarrow R_{x,31}$ if $i + shift \geq 32$
\effect $R_r \leftarrow temp$
\end{effectize}

\subsection{LDHI}

The LDHI instruction is used to generate large constants. The upper 16 bits of the result are taken from the 16-bit immediate operand. The lower 16 bits of the result are 0.\\

\rriformat{011111}

\begin{effectize}
\effect $R_{r,31..16} \leftarrow y_{15..0}$
\effect $R_{r,15..0} \leftarrow 0$
\end{effectize}
